(function (global) {
  const defaultColors = [
    "#26ccff", "#a25afd", "#ff5e7e",
    "#88ff5a", "#fcff42", "#ffa62d", "#ff36ff"
  ];

  function random(min, max) {
    return Math.random() * (max - min) + min;
  }

  function createParticle(options) {
    const angle = options.angle * (Math.PI / 180);
    const spread = options.spread * (Math.PI / 180);

    return {
      x: options.x * options.canvas.width,
      y: options.y * options.canvas.height,
      wobble: random(0, 10),
      wobbleSpeed: random(0.1, 0.2),
      velocity: options.startVelocity * 0.5 + random(0, options.startVelocity),
      angle2D: -angle + (0.5 * spread - random(0, spread)),
      tiltAngle: random(0, Math.PI),
      color: options.colors[Math.floor(Math.random() * options.colors.length)],
      shape: options.shapes[Math.floor(Math.random() * options.shapes.length)],
      tick: 0,
      totalTicks: options.ticks,
      decay: options.decay,
      drift: options.drift,
      gravity: options.gravity * 3,
      scalar: options.scalar,
      random: random(2, 4),
    };
  }

  function renderParticles(canvas, particles, context, callback) {
    function drawFrame() {
      context.clearRect(0, 0, canvas.width, canvas.height);

      particles.forEach((p, index) => {
        p.x += Math.cos(p.angle2D) * p.velocity + p.drift;
        p.y += Math.sin(p.angle2D) * p.velocity + p.gravity;
        p.wobble += p.wobbleSpeed;
        p.velocity *= p.decay;

        const alpha = 1 - p.tick / p.totalTicks;
        context.fillStyle = `${p.color}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`;

        context.beginPath();
        if (p.shape === 'circle') {
          context.ellipse(p.x, p.y, 6 * p.scalar, 6 * p.scalar, 0, 0, 2 * Math.PI);
        } else {
          context.fillRect(p.x, p.y, 8 * p.scalar, 8 * p.scalar);
        }
        context.fill();

        p.tick++;
        if (p.tick >= p.totalTicks) {
          particles.splice(index, 1);
        }
      });

      if (particles.length) {
        requestAnimationFrame(drawFrame);
      } else if (callback) {
        callback();
      }
    }

    drawFrame();
  }

  function confetti(options = {}) {
    const canvas = options.canvas || document.createElement("canvas");
    const shouldAppend = !options.canvas;
    const context = canvas.getContext("2d");

    if (shouldAppend) {
      canvas.style.position = "fixed";
      canvas.style.top = "0";
      canvas.style.left = "0";
      canvas.style.width = "100%";
      canvas.style.height = "100%";
      canvas.style.pointerEvents = "none";
      canvas.style.zIndex = options.zIndex || 100;
      document.body.appendChild(canvas);

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
    }

    const particleCount = options.particleCount || 100;
    const particles = [];

    for (let i = 0; i < particleCount; i++) {
      particles.push(
        createParticle({
          angle: options.angle || 90,
          spread: options.spread || 45,
          startVelocity: options.startVelocity || 45,
          decay: options.decay || 0.9,
          gravity: options.gravity || 1,
          drift: options.drift || 0,
          ticks: options.ticks || 200,
          x: options.x !== undefined ? options.x : 0.5,
          y: options.y !== undefined ? options.y : 0.5,
          shapes: options.shapes || ["square", "circle"],
          colors: options.colors || defaultColors,
          scalar: options.scalar || 1,
          canvas: canvas
        })
      );
    }

    renderParticles(canvas, particles, context, () => {
      if (shouldAppend) {
        document.body.removeChild(canvas);
      }
    });
  }

  // Export
  global.confetti = confetti;
})(window);